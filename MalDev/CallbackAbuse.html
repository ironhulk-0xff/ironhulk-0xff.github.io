<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Iron Hulk – Callback Abuse</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-[#0f172a] text-white font-sans min-h-screen">
  <!-- Header -->
  <header class="bg-[#1e293b] p-4 shadow flex items-center justify-between gap-4">
    <div>
      <h1 class="text-xl font-bold text-blue-400">Callback Abuse</h1>
      <small id="reading-time" class="text-xs text-gray-400"></small>
    </div>
    <a href="../index.html" class="text-gray-200  hover:underline">← Back to Dashboard</a>
  </header>
<main id="article" class="p-6 space-y-6 sm:text-justify ">
  <section class="relative mx-auto overflow-hidden rounded-3xl bg-gradient-to-br from-slate-800/90 via-slate-900 to-black p-10 ring-1 ring-cyan-500/20">
    <div class="pointer-events-none absolute -top-24 -left-24 h-64 w-64 rounded-full bg-cyan-500/20 blur-3xl"></div>
      <div class="pointer-events-none absolute -bottom-28 -right-28 h-72 w-72 rounded-full bg-indigo-600/20 blur-3xl"></div>
      <article class="space-y-6">
        <h2 class="text-center text-3xl font-extrabold tracking-tight text-transparent bg-gradient-to-r from-cyan-400 via-sky-400 to-indigo-400 bg-clip-text">
          Callback Functions, Concept and Purpose:</h2>
        <div class="rounded-xl border border-cyan-400/20 bg-gray-900/60 p-6 shadow-xl backdrop-blur-md">
          <p class=" leading-relaxed text-gray-200">
            <strong>Callback abuse</strong> is the technique of handing a pointer to your own code (the “callback”) into a legitimate system or library function so that, when a normal event or 
            condition occurs, that function unwittingly “calls back” into your malicious logic. By doing so you piggy-back on trusted infrastructure, timers, GUI loops, I/O 
            completions, exception handlers, so your code runs under the guise of normal behavior. This avoids creating new threads or processes and dramatically reduces the 
            noise defenders see, making your payload far stealthier. <br><br>
            This inversion of control is what makes callbacks so powerful:
            <ul class="text-gray-200">
              <li class="flex items-start gap-3">
                <span class="mt-1 inline-block h-2.5 w-2.5 flex-none rounded-full bg-cyan-400"></span>
                <span><strong>Event-driven flow:</strong> Your code runs only when it matters (Ex: a timer fires, a window receives a message, an I/O completes).</span>
              </li>
              <li class="flex items-start gap-3">
                <span class="mt-1 inline-block h-2.5 w-2.5 flex-none rounded-full bg-cyan-400"></span>
                <span><strong>Thread reuse:</strong> Because the operating system or library already owns a pool of threads, you rarely need to create one yourself.</span>
              </li>
              <li class="flex items-start gap-3">
                <span class="mt-1 inline-block h-2.5 w-2.5 flex-none rounded-full bg-cyan-400"></span>
                <span><strong>Stealth:</strong> Since no explicit <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">CreateThread</code> call appears in your code, detection logic that keys off thread creation often misses the execution entirely.</span>
              </li>
            </ul>
          </p>
        </div>
      </article>
      <br>
      <section class="relative rounded-2xl bg-gradient-to-br from-gray-800/70 to-gray-900/90 p-8 shadow-2xl ring-1 ring-blue-500/20 overflow-hidden">
        <div class="pointer-events-none absolute -top-24 -left-24 h-64 w-64 rounded-full "></div>
        <h2 class="text-3xl font-extrabold text-center bg-clip-text text-transparent bg-gradient-to-r from-blue-400 via-sky-400 to-indigo-400 mb-10">
          Callback Abuse Cheat-Sheet</h2>
        <div class="space-y-4">
          <details class="group rounded-xl bg-gray-800/60 ring-1 ring-gray-700/60 overflow-hidden">
            <summary class="flex items-center justify-between px-6 py-4 cursor-pointer select-none">
              <div class="max-w-full overflow-x-auto">
                <span class="inline-block whitespace-nowrap font-semibold text-sky-300">
                  CreateTimerQueueTimer
                </span>
              </div>
                <svg class="w-5 h-5 text-gray-400 group-open:rotate-90 transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none"
                  viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
              </svg>
            </summary>
            <div class="px-6 pb-6 pt-2  text-gray-200 space-y-1">
              <p><span class="font-bold text-cyan-500">Definition:</span> Is a Windows API that lets you schedule a function (your “callback”) to run once after a delay you choose or to repeat at a regular interval.</p>
              <p><span class="font-bold text-cyan-500">When it fires:</span> After a delay you set, then repeatedly on a built-in thread-pool timer</p>
              <p><span class="font-bold text-cyan-500">Where it runs:</span> A background worker thread inside the same process</p>
              <p><span class="font-bold text-cyan-500">Why attackers use it:</span> Easy “sleep-then-wake” for payloads without creating a new thread</p>
              <p><span class="font-bold text-cyan-500">Attack process:</span> </p>
                <ol class="list-[disck] list-outside pl-8 text-gray-200 text-[15px] leading-relaxed sm:text-justify">
                  <li>Allocate RWX or RX memory and copy your shellcode or stub there</li>
                  <li>Call <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">CreateTimerQueueTimer(&hTimer, NULL, MyCallbackFunction, myContextPointer, dueTime, period, 0)</code>.</li>
                  <li><code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">myContextPointer</code> is optional data you pass in.</li>
                </ol>
              <p>
              <span class="font-bold text-cyan-500">What defenders can spot:</span> ETW <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">ThreadPoolTimer</code> events or periodic CPU bursts.</p>
              <br>
              <p><span class="font-bold text-cyan-500"><code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">CreateTimerQueueTimer</code> by itself is a perfectly legitimate Windows API and won’t trip AV or EDR just because you called it. What gets flagged is how you use it:</span> </p>
                <ol class="list-[disck] list-outside pl-8 text-gray-200 text-[15px] leading-relaxed sm:text-justify">
                  <li><strong>Callback in non-image memory:</strong> If the function pointer you registered lives in heap/RWX memory rather than inside a signed DLL or EXE image, EDRs will log “callback into executable heap.”</li>
                  <li><strong>Heap/RWX allocations beforehand:</strong> VirtualAlloc’ing a large RWX region, writing shellcode there, then immediately scheduling it via <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">CreateTimerQueueTimer</code> looks very suspicious.</li>
                  <li><strong>Unusual timer patterns:</strong> Rapid, high-frequency timers or timers set far in the future and never reset can trigger heuristic rules.</li>
                  <li><strong>ETW/Telemetry anomalies:</strong> Defenders monitor the ThreadPoolTimer ETW provider; if callback addresses jump around or point into non-standard regions, that’s a red flag.</li>
                </ol>
              <p><br>
              <p><span class="text-gray-500">Thank you, MalDev Academy, for imparting this knowledge.</span> </p>
            </div>
          </details>
          <details class="group rounded-xl bg-gray-800/60 ring-1 ring-gray-700/60 overflow-hidden">
            <summary class="flex items-center justify-between px-6 py-4 cursor-pointer select-none">
              <div class="max-w-full overflow-x-auto">
                <span class="inline-block whitespace-nowrap font-semibold text-sky-300">
                  EnumWindows/EnumChildWindows
                </span>
              </div>
              <svg class="w-5 h-5 text-gray-400 group-open:rotate-90 transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none"
                  viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
              </svg>
            </summary>
            <div class="px-6 pb-6 pt-2  text-gray-200 space-y-1">
              <p><span class="font-bold text-cyan-500">Definition:</span> Is a Windows API function that lets a program discover all top-level desktop windows or child windows currently open on the system.</p>
              <p><span class="font-bold text-cyan-500">When it fires:</span> Each time Windows loops through open windows (Ex: a GUI refresh).</p>
              <p><span class="font-bold text-cyan-500">Where it runs:</span> The application’s main GUI thread during that loop.</p>
              <p><span class="font-bold text-cyan-500">Why attackers use it:</span> Blends into real GUI activity; defenders see “<code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">EnumWindows</code>” on the call stack, which is common in UI tools.</p>
              <p><span class="font-bold text-cyan-500">Attack process:</span> </p>
                <ol class="list-[disck] list-outside pl-8 text-gray-200 text-[15px] leading-relaxed sm:text-justify">
                  <li>Inject a DLL into the target process, Ex: via <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">CreateRemoteThread</code> + <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">LoadLibrary</code>.</li>
                  <li>In that DLL, call <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">EnumWindows (MyEnumProc, param)</code> where <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">MyEnumProc</code> points into your code.</li>
                  <li>Inside <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">MyEnumProc</code>, locate a writable region or perform your malicious action.</li>
                </ol>
              <p>
                <span class="font-bold text-cyan-500">What defenders can spot:</span> Unusual call stacks in <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">user32!EnumWindows</code> carrying RX pages.</p>
                <br>
                <p><span class="font-bold text-cyan-500">EDR and AV products generally don’t block or flag a plain <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">EnumWindows</code> call, by itself it’s a perfectly normal GUI API. What they look for are anomalies around how you use it:</span> </p>
                <ol class="list-[disck] list-outside pl-8 text-gray-200 text-[15px] leading-relaxed sm:text-justify">
                  <li><strong>Callback address in non-standard memory:</strong> If your <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">WNDENUMPROC</code> pointer lives in RWX or heap memory instead of a legit module, EDRs will surface that as a “callback into non-image region.”</li>
                  <li><strong>Tight, repeated loops:</strong> Calling <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">EnumWindows</code> hundreds or thousands of times per second or in rapid succession across many processes can trip heuristic rate-based rules.</li>
                  <li><strong>DLL injection and reflective loading:</strong> Most malicious uses of <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">EnumWindows</code> follow a DLL-inject → LoadLibrary or reflective loader chain. The injection and memory protections (noperms, RWX) are higher-confidence signals than the enumeration itself.</li>
                  <li><strong>Suspicious call-stack sequences:</strong> EDRs can detect <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">user32!EnumWindows</code> → your callback → VirtualProtect+CreateThread” patterns. Correlating GUI enumeration with memory-allocation APIs spikes the alert priority.</li>
                  <li><strong>Combined behaviors:</strong> <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">EnumWindows</code> used alongside process enumeration (CreateToolhelp32Snapshot), module dumping (DbgHelp), or registry reads in the same timeframe often forms a kill chain that gets flagged.</li>
                </ol>
              <p>
              <br>
              <blockquote class="border-l-4 border-blue-400 pl-4 italic">
                Bottom line: a single, infrequent <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">EnumWindows</code> in a signed DLL isn’t enough to trip modern EDR. However, if your callback lives in RX heap, fires in a tight loop 
                (you’ll see rapidly changing hWnd values each invocation), or immediately unrolls into reflective loading, detection engines will key on that behavioral context, not 
                the API name alone.
              </blockquote>
            </div>
          </details>
          <details class="group rounded-xl bg-gray-800/60 ring-1 ring-gray-700/60 overflow-hidden">
            <summary class="flex items-center justify-between px-6 py-4 cursor-pointer select-none">
              <div class="max-w-full overflow-x-auto">
                <span class="inline-block whitespace-nowrap font-semibold text-sky-300">
                  QueueUserAPC/NtQueueApcThread
                </span>
              </div>
              <svg class="w-5 h-5 text-gray-400 group-open:rotate-90 transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none"
                  viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
              </svg>
            </summary>
            <div class="px-6 pb-6 pt-2  text-gray-200 space-y-1">
              <p><span class="font-bold text-cyan-500">Definition:</span> Queues an “asynchronous procedure call” to run in a target thread when it next enters an alertable wait state.</p>
              <p><span class="font-bold text-cyan-500">When it fires:</span> As soon as a chosen thread enters an alertable wait <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">SleepEx</code>.</p>
              <p><span class="font-bold text-cyan-500">Where it runs:</span> Inside that already-running thread—no new threads needed</p>
              <p><span class="font-bold text-cyan-500">Why attackers use it:</span> Blends into existing threads and dodges thread-creation alerts</p>
              <p><span class="font-bold text-cyan-500">Attack process:</span> </p>
                <ol class="list-[disck] list-outside pl-8 text-gray-200 text-[15px] leading-relaxed sm:text-justify">
                  <li>Open a handle to a thread in the target process with <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">THREAD_SET_CONTEXT</code>.</li>
                  <li>Allocate memory for your shellcode and copy it into the target.</li>
                  <li>Call <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">QueueUserAPC(MyApcFunc, hThread, param)</code>.</li>
                  <li>Force or wait for an alertable wait in that thread, and when that thread calls <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">SleepEx(..., TRUE)</code> or <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">WaitForSingleObjectEx(..., TRUE)</code>, the OS suspends its wait and invokes <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">MyApcFunc(myParameter);</code></li>
                </ol>
              <p>
              <span class="font-bold text-cyan-500">What defenders can spot:</span> APC injections logged by EDR or a big jump in queued APCs.</p>
              <br>
              <p><span class="font-bold text-cyan-500">Calling <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">QueueUserAPC</code> or the underlying syscall <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">NtQueueApcThread</code>, isn’t malicious and won’t trip AV/EDR signatures—but defenders do watch for the broader “APC injection” pattern. They flag when:</span> </p>
              <ol class="list-[disck] list-outside pl-8 text-gray-200 text-[15px] leading-relaxed sm:text-justify">
                <li><strong>Your APC address lives in non-image memory:</strong> Pointing the callback into a freshly-allocated RWX heap or the writeable section of a reflective DLL looks suspicious.</li>
                <li><strong>You open a remote thread handle & queue APCs:</strong> Repeated calls to <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">OpenThread</code> + <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">QueueUserAPC</code> into another process mean thread-hijacking.</li>
                <li><strong>The target thread never enters a legit alertable wait:</strong> Continuously poking APCs without real <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">SleepEx/WaitFor…Ex</code> usage rings alarms.</li>
                <li><strong>Suspicious call-stack sequences:</strong> <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">VirtualAlloc</code> + <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">WriteProcessMemory</code> then immediate APC queueing is a high-confidence indicator of shellcode injection.</li>
              </ol>
              <p>
            </div>
          </details>
          <details class="group rounded-xl bg-gray-800/60 ring-1 ring-gray-700/60 overflow-hidden">
            <summary class="flex items-center justify-between px-6 py-4 cursor-pointer select-none">
              <div class="max-w-full overflow-x-auto">
                <span class="inline-block whitespace-nowrap font-semibold text-sky-300">
                  SetWinEventHook
                </span>
              </div>
              <svg class="w-5 h-5 text-gray-400 group-open:rotate-90 transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none"
                  viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
              </svg>
            </summary>
            <div class="px-6 pb-6 pt-2  text-gray-200 space-y-1">
              <p><span class="font-bold text-cyan-500">Definition:</span> Is a Windows API that lets an application subscribe to system-level or process-level UI events, things like window creation, focus changes, minimize/restore, or object events (menu open, scrollbar move). You provide a function pointer <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">WINEVENTPROC</code> and flags defining which events you want. Whenever one of those events occurs, Windows “calls back” into your function.</p>
              <p><span class="font-bold text-cyan-500">When it fires:</span> On focus changes, minimize/restore, or other user-interface events.</p>
              <p><span class="font-bold text-cyan-500">Where it runs:</span> Callback on almost any GUI activity while the hook is set.</p>
              <p><span class="font-bold text-cyan-500">Why attackers use it:</span> Provides long-lived, low-CPU persistence tied to user actions.</p>
              <p><span class="font-bold text-cyan-500">Attack process:</span> </p>
                <ol class="list-[disck] list-outside pl-8 text-gray-200 text-[15px] leading-relaxed sm:text-justify">
                  <li>Call <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_MINIMIZEEND, NULL, MyWinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT)</code>.</li>
                  <li>In <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">MyWinEventProc</code>, perform your payload action or inject further code.</li>
                </ol>
              <p>
              <span class="font-bold text-cyan-500">What defenders can spot:</span> Extra window-event hooks and unfamiliar DLLs kept loaded.</p>
              <br>
              <p><span class="font-bold text-cyan-500">Why EDR/AV don’t flag the API itself:</span> </p>
              <ol class="list-[disck] list-outside pl-8 text-gray-200 text-[15px] leading-relaxed sm:text-justify">
                <li><strong>Legitimate, built-in use:</strong> Accessibility tools, screen readers, UI-automation frameworks, and testing suites rely on SetWinEventHook to know when UI state changes. It’s a core part of the Windows accessibility and automation model.</li>
                <li><strong>No overt injection:</strong> Simply registering a hook doesn’t require injecting code into other processes or creating remote threads, everything operates in your own process’s context unless you deliberately request out-of-context hooks.</li>
                <li><strong>High false-positive risk:</strong> Blocking or alerting on every SetWinEventHook call would break countless legitimate applications, so EDR/AV focus on how it’s used hook flags, callback address regions, accompanying suspicious behaviors, rather than on the function name alone.</li>
              </ol>
              <p>
                <blockquote class="border-l-4 border-blue-400 pl-4 italic">
                  Bottom line: This console application installs a <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">WinEvent</code> hook to catch when the foreground window changes, runs a lightweight message loop so the hook can fire, 
                  pops up a MessageBox once on the first focus shift, then automatically unhooks and exits.
                </blockquote>
              </div>
          </details>
          <details class="group rounded-xl bg-gray-800/60 ring-1 ring-gray-700/60 overflow-hidden">
            <summary class="flex items-center justify-between px-6 py-4 cursor-pointer select-none">
              <div class="max-w-full overflow-x-auto">
                <span class="inline-block whitespace-nowrap font-semibold text-sky-300">
                  RegisterWaitForSingleObject
                </span>
              </div>
              <svg class="w-5 h-5 text-gray-400 group-open:rotate-90 transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none"
                  viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
              </svg>
            </summary>
            <div class="px-6 pb-6 pt-2  text-gray-200 space-y-1">
              <p><span class="font-bold text-cyan-500">Definition:</span> This API lets you tell Windows “watch this handle (event, mutex, process, timer) and when it’s signaled or after a timeout call my function on a thread-pool thread.” It’s a convenient way to schedule work without blocking your main thread or spinning in a loop.</p>
              <p><span class="font-bold text-cyan-500">When it fires:</span> When a handle you watch (event, mutex, process, etc.) is signaled or times out</p>
              <p><span class="font-bold text-cyan-500">Where it runs:</span> A thread-pool worker thread.</p>
              <p><span class="font-bold text-cyan-500">Why attackers use it:</span> Lets payload trigger only after a specific condition (Ex: service starts).</p>
              <p><span class="font-bold text-cyan-500">Attack process:</span> </p>
                <ol class="list-[disck] list-outside pl-8 text-gray-200 text-[15px] leading-relaxed sm:text-justify">
                  <li>Create or open a synchronization object (Ex: named event).</li>
                  <li>Call <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">RegisterWaitForSingleObject(&waitHandle, hObject, MyCallback, param, INFINITE, WT_EXECUTEDEFAULT)</code>.</li>
                  <li>In <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">MyCallback</code>, move to next stage or drop a payload.</li>
                </ol>
              <p>
              <span class="font-bold text-cyan-500">What defenders can spot:</span> New wait objects listed by <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">NtQueryObject</code> or ETW <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">ThreadPoolWait</code> events.</p>
              <br>
              <p><span class="font-bold text-cyan-500">EDR/AV will flag it if:</span> </p>
              <ol class="list-[disck] list-outside pl-8 text-gray-200 text-[15px] leading-relaxed sm:text-justify">
                <li><strong>Callback pointer in non-image memory:</strong> Registering a wait whose callback lives in RWX heap or a reflective DLL triggers “callback into non-image region” alerts.</li>
                <li><strong>Suspicious memory patterns:</strong> Allocating a big RWX region immediately before calling RegisterWaitForSingleObject—the combo looks like shellcode staging.</li>
                <li><strong>High-volume or out-of-context waits:</strong> Spawning hundreds of wait registrations on handles you created (instead of reusing a single wait or timer) can hit rate-based heuristics.</li>
                <li><strong>ETW telemetry:</strong> The Microsoft-Windows-ThreadPool/Operational provider logs ThreadPoolWait events; unusual callback addresses or too many concurrent waits stand out.</li>
              </ol>
              <p>
            </div>
          </details>
          <details class="group rounded-xl bg-gray-800/60 ring-1 ring-gray-700/60 overflow-hidden">
            <summary class="flex items-center justify-between px-6 py-4 cursor-pointer select-none">
              <div class="max-w-full overflow-x-auto">
                <span class="inline-block whitespace-nowrap font-semibold text-sky-300">
                  RtlInstallFunctionTableCallback
                </span>
              </div>
              <svg class="w-5 h-5 text-gray-400 group-open:rotate-90 transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none"
                  viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
              </svg>
            </summary>
            <div class="px-6 pb-6 pt-2  text-gray-200 space-y-1">
              <p><span class="font-bold text-cyan-500">Definition:</span> lets code register its own unwind-information provider for a given memory range so the OS can correctly walk your stack and handle exceptions in that range.</p>
              <p><span class="font-bold text-cyan-500">When it fires:</span> First time the system tries to unwind an exception in a chosen memory range.</p>
              <p><span class="font-bold text-cyan-500">Where it runs:</span> In the thread that just crashed or triggered an exception.</p>
              <p><span class="font-bold text-cyan-500">Why attackers use it:</span> Turns a “controlled crash” into execution without direct API calls.</p>
              <p><span class="font-bold text-cyan-500">Attack process:</span> </p>
                <ol class="list-[disck] list-outside pl-8 text-gray-200 text-[15px] leading-relaxed sm:text-justify">
                  <li>Allocate a memory region marked RX and copy your payload there.</li>
                  <li>Call <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">RtlInstallFunctionTableCallback(address, size, MyUnwindCallback, Context)</code>.</li>
                  <li>Deliberately cause an exception in that range—OS calls your unwind callback, which jumps into payload.</li>
                </ol>
              <p>
              <span class="font-bold text-cyan-500">What defenders can spot:</span> Dynamic function tables pointing to writable/executable memory.</p>
            </div>
          </details>
          <details class="group rounded-xl bg-gray-800/60 ring-1 ring-gray-700/60 overflow-hidden">
            <summary class="flex items-center justify-between px-6 py-4 cursor-pointer select-none">
              <div class="max-w-full overflow-x-auto">
                <span class="inline-block whitespace-nowrap font-semibold text-sky-300">
                  CreateThreadpoolIo
                </span>
              </div>
              <svg class="w-5 h-5 text-gray-400 group-open:rotate-90 transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none"
                  viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
              </svg>
            </summary>
            <div class="px-6 pb-6 pt-2 text-gray-200 space-y-1">
              <p><span class="font-bold text-cyan-500">Definition:</span> lets an application offload asynchronous I/O operations (files, sockets, pipes) to a managed thread-pool. </p>
              <p><span class="font-bold text-cyan-500">When it fires:</span> After an asynchronous file, socket, or pipe I/O completes</p>
              <p><span class="font-bold text-cyan-500">Where it runs:</span> A thread-pool I/O worker.</p>
              <p><span class="font-bold text-cyan-500">Why attackers use it:</span> Hides payload inside normal async I/O flow (Ex: network traffic).</p>
              <p><span class="font-bold text-cyan-500">Attack process:</span> </p>
                <ol class="list-[disck] list-outside pl-8 text-gray-200 text-[15px] leading-relaxed sm:text-justify">
                  <li>Call <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">CreateThreadpoolIo(hFile, MyIoCallback, Context, NULL)</code>.</li>
                  <li>Start an overlapped read/write on that handle.</li>
                  <li>When data arrives or write completes, <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">MyIoCallback</code> will executes your code.</li>
                </ol>
              <p>
              <span class="font-bold text-cyan-500">What defenders can spot:</span> I/O callbacks to non-image memory and mismatched I/O patterns.</p>
            </div>
          </details>
        </div>
      </section>
      <br>
      <article class="space-y-6 pt-12">
        <div class="rounded-xl border border-cyan-400/20 bg-gray-900/60 p-6 shadow-xl">
          <h2 class="text-center text-3xl font-extrabold tracking-tight text-transparent bg-gradient-to-r from-cyan-400 via-sky-400 to-indigo-400 bg-clip-text">
            Closing Thoughts</h2>
          <ul class="space-y-3 text-gray-200">
            <li class="flex items-start gap-3">
              <span class="mt-1 inline-block h-2.5 w-2.5 flex-none rounded-full bg-sky-400"></span>
              Delays launch to dodge “first-few-seconds” sandbox rules.
            </li>
            <li class="flex items-start gap-3">
              <span class="mt-1 inline-block h-2.5 w-2.5 flex-none rounded-full bg-sky-400"></span>
              Keeps opcode patterns hidden until runtime.
            </li>
            <li class="flex items-start gap-3">
              <span class="mt-1 inline-block h-2.5 w-2.5 flex-none rounded-full bg-sky-400"></span>
              Avoids thread-creation events most EDRs prioritise.
            </li>
          </ul>
        </div>
      </article>
      <section class="px-6 relative w-full my-10  overflow-hidden rounded-3xl bg-gradient-to-br from-slate-800 via-slate-900 to-black shadow-2xl ring-1 ring-cyan-400/30">
        <div class="w-full flex justify-center">
          <h2 class="relative z-10 flex flex-col px-2 md:flex-row md:items-start md:py-10 text-center text-3xl md:text-4xl font-extrabold tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 via-sky-400 to-indigo-400 drop-shadow-lg">
            Proof of Concept </h2>
        </div>
        <div class="grid gap-10 sm:grid-cols-2 lg:grid-cols-1">
          <figure class="group relative overflow-hidden rounded-2xl bg-slate-900/60 ring-1 ring-slate-700/60 shadow-xl">
            <figcaption class="mt-3 text-center  text-white">Run it </figcaption>
            <img src="../MalDev/images/callback_Runner.png" alt="Describe image" class="w-full object-cover transition-transform " />
          </figure>
          <br>
      </div>
    </section>
    <blockquote class="border-l-4 border-blue-400 pl-4 italic">
      In the above proof-of-concept, we leveraged the CreateTimerQueueTimer callback to display a MessageBox. As mentioned, the timer itself doesn’t trip AV/EDR, but anything it triggers 
      afterward is closely watched. This is just our first milestone, there’s still a long, challenging road ahead before we can outmaneuver every security layer.
    </blockquote>
    <section class="px-6 relative w-full my-10  overflow-hidden rounded-3xl bg-gradient-to-br from-slate-800 via-slate-900 to-black shadow-2xl ring-1 ring-cyan-400/30">
      <div class="absolute -bottom-16 -right-16 w-72 h-72 bg-gradient-to-br from-green-400 to-blue-600 opacity-30 blur-3xl animate-blob animation-delay-2000"></div>
      <div class="relative space-y-6">
        <div class="w-full flex justify-center">
          <h2 class="relative z-10 flex flex-col px-2 md:flex-row md:items-start md:py-10 text-center text-3xl md:text-4xl font-extrabold tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 via-sky-400 to-indigo-400 drop-shadow-lg">
            My C# Project </h2>
        </div>
        <details class="bg-gray-800 bg-opacity-50 p-4 rounded-lg group">
          <summary class="flex items-center justify-between text-xl font-semibold text-cyan-500 cursor-pointer ">
            <div class="max-w-full overflow-x-auto">
              <span class="inline-block whitespace-nowrap font-semibold text-cyan-500">
                CreateTimerQueueTimer Abuse
              </span>
            </div>
            <svg class="w-6 h-6 transform transition-transform duration-200 group-open:rotate-180 text-cyan-500" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"/>
            </svg>
          </summary>
          <div class="mt-4 relative ">
            <button class="absolute top-2 right-2 bg-indigo-500 text-white px-3 py-1 rounded text-sm" onclick="copyCode(this)">Copy</button>
            <pre class="mt-8 overflow-x-auto bg-gray-900 p-4 rounded-lg shadow-inner ">
              <code class="language-csharp text-green-300">
                using System;
                using System.Runtime.InteropServices;
                using System.Threading;

                class Program
                {
                    // Delegate matching WAITORTIMERCALLBACK
                    private delegate void TimerCallback(IntPtr lpParameter, bool timerFired);

                    [DllImport("kernel32.dll", SetLastError = true)]
                    private static extern bool CreateTimerQueueTimer(
                        out IntPtr phNewTimer,
                        IntPtr timerQueue,
                        TimerCallback callback,
                        IntPtr parameter,
                        uint dueTime,
                        uint period,
                        uint flags
                    );

                    [DllImport("user32.dll", CharSet = CharSet.Auto)]
                    private static extern int MessageBox(IntPtr hWnd, string text, string caption, uint type);

                    static void Main()
                    {
                        // Schedule a one-shot timer 2 seconds from now
                        if (!CreateTimerQueueTimer(
                            out IntPtr timerHandle,
                            IntPtr.Zero,
                            TimerFired,
                            IntPtr.Zero,
                            2000,   // dueTime = 2000ms
                            0,      // period = 0 (one-shot)
                            0
                        ))
                        {
                            Console.WriteLine("CreateTimerQueueTimer failed: " + Marshal.GetLastWin32Error());
                            return;
                        }

                        // Debug output
                        Console.WriteLine("Timer scheduled. Waiting for callback...");
                        Thread.Sleep(Timeout.Infinite);

                    }

                    // This method runs on a thread-pool thread when the timer fires
                    private static void TimerFired(IntPtr lpParameter, bool timerFired)
                    {
                        MessageBox(IntPtr.Zero, "Hello from a timer callback!", "Callback Abuse", 0);
                        Environment.Exit(0);
                    }
                }
              </code>
            </pre>
          </div>
        </details>
        <details class="bg-gray-800 bg-opacity-50 p-4 rounded-lg group">
          <summary class="flex items-center justify-between text-xl font-semibold text-cyan-500 cursor-pointer ">
            <div class="max-w-full overflow-x-auto">
              <span class="inline-block whitespace-nowrap font-semibold text-cyan-500">
                EnumWindows/EnumChildWindows Abuse
              </span>
            </div>
            <svg class="w-6 h-6 transform transition-transform duration-200 group-open:rotate-180 text-cyan-500" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"/>
            </svg>
          </summary>
          <div class="mt-4 relative ">
            <button class="absolute top-2 right-2 bg-indigo-500 text-white px-3 py-1 rounded text-sm" onclick="copyCode(this)">Copy</button>
            <pre class="mt-8 overflow-x-auto bg-gray-900 p-4 rounded-lg shadow-inner ">
              <code class="language-csharp text-green-300">
                using System;
                using System.Runtime.InteropServices;
                using System.Text;
                class Program
                {
                    // Flag to ensure only one callback fires for child windows
                    private static bool _childShown;

                    // Delegate for the window‐enumeration callbacks
                    private delegate bool WndEnumProc(IntPtr hWnd, IntPtr lParam);

                    [DllImport("user32.dll", SetLastError = true)]
                    private static extern bool EnumWindows(WndEnumProc lpEnumFunc, IntPtr lParam);

                    [DllImport("user32.dll", SetLastError = true)]
                    private static extern bool EnumChildWindows(IntPtr hWndParent, WndEnumProc lpEnumFunc, IntPtr lParam);

                    [DllImport("user32.dll")]
                    private static extern IntPtr GetDesktopWindow();

                    [DllImport("user32.dll", CharSet = CharSet.Auto)]
                    private static extern int MessageBox(IntPtr hWnd, string text, string caption, uint type);

                    static void Main()
                    {
                        Console.WriteLine("Calling EnumWindows…");
                        EnumWindows(EnumWindowsCallback, IntPtr.Zero);

                        Console.WriteLine("Calling EnumChildWindows on desktop…");
                        EnumChildWindows(GetDesktopWindow(), EnumChildWindowsCallback, IntPtr.Zero);

                        Console.WriteLine("Done. Press any key to exit.");
                        Console.ReadKey();
                    }

                    private static bool EnumWindowsCallback(IntPtr hWnd, IntPtr lParam)
                    {
                        // Show a MessageBox once, then stop enumeration
                        MessageBox(IntPtr.Zero,
                            $"EnumWindows callback fired for hWnd=0x{hWnd:X}",
                            "EnumWindows Abuse", 0);
                        return false;  // halt after first callback
                    }

                    // This will stop for all EnumChildWindowsCallback
                    /*
                    private static bool EnumChildWindowsCallback(IntPtr hWnd, IntPtr lParam)
                    {
                        // Show a MessageBox for each child (you can return true to continue)
                        MessageBox(IntPtr.Zero, $"EnumChildWindows callback for child hWnd=0x{hWnd:X}",
                                  "EnumChildWindows Abuse", 0);
                        return true;   // return true to continue through all children
                    }
                    */
                    // This will stop for one EnumChildWindowsCallback
                    
                    private static bool EnumChildWindowsCallback(IntPtr hWnd, IntPtr lParam)
                    {
                        if (_childShown)
                            return false;  // already shown, stop enumeration

                        _childShown = true;
                        MessageBox(IntPtr.Zero,
                            $"EnumChildWindows callback fired for child hWnd=0x{hWnd:X}",
                            "EnumChildWindows Abuse", 0);

                        return false;  // stop after first child callback
                    }
                }
              </code>
            </pre>
          </div>
        </details>
        <details class="bg-gray-800 bg-opacity-50 p-4 rounded-lg group">
          <summary class="flex items-center justify-between text-xl font-semibold text-cyan-500 cursor-pointer ">
            <div class="max-w-full overflow-x-auto">
              <span class="inline-block whitespace-nowrap font-semibold text-cyan-500">
                QueueUserAPC/NtQueueApcThread Abuse
              </span>
            </div>
            <svg class="w-6 h-6 transform transition-transform duration-200 group-open:rotate-180 text-cyan-500" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"/>
            </svg>
          </summary>
          <div class="mt-4 relative ">
            <button class="absolute top-2 right-2 bg-indigo-500 text-white px-3 py-1 rounded text-sm" onclick="copyCode(this)">Copy</button>
            <pre class="mt-8 overflow-x-auto bg-gray-900 p-4 rounded-lg shadow-inner ">
              <code class="language-csharp text-green-300">
                using System;
                using System.Runtime.InteropServices;
                class Program
                {
                    // APC callback signature
                    private delegate void ApcProc(UIntPtr dwParam);

                    [DllImport("kernel32.dll", SetLastError = true)]
                    private static extern IntPtr OpenThread(
                        uint dwDesiredAccess,
                        bool bInheritHandle,
                        uint dwThreadId
                    );

                    [DllImport("kernel32.dll", SetLastError = true)]
                    private static extern uint QueueUserAPC(
                        ApcProc pfnAPC,
                        IntPtr hThread,
                        UIntPtr dwData
                    );

                    [DllImport("kernel32.dll")]
                    private static extern uint SleepEx(
                        uint dwMilliseconds,
                        bool bAlertable
                    );

                    [DllImport("kernel32.dll")]
                    private static extern uint GetCurrentThreadId();

                    [DllImport("user32.dll", CharSet = CharSet.Auto)]
                    private static extern int MessageBox(
                        IntPtr hWnd,
                        string text,
                        string caption,
                        uint type
                    );

                    static void Main()
                    {
                        Console.WriteLine("Opening current thread handle...");
                        uint tid = GetCurrentThreadId();
                        IntPtr hThread = OpenThread(0x0010, false, tid);

                        Console.WriteLine("Queueing APC to ourselves...");
                        QueueUserAPC(ApcCallback, hThread, UIntPtr.Zero);

                        Console.WriteLine("Entering alertable wait (SleepEx 5s)...");
                        SleepEx(5000, true);

                        Console.WriteLine("Finished. If APC fired, you saw a MessageBox.");
                    }

                    // Runs when SleepEx is in alertable state
                    private static void ApcCallback(UIntPtr dwParam)
                    {
                        MessageBox(IntPtr.Zero, "Hello from APC callback!", "APC Abuse", 0);
                    }
                }
              </code>
            </pre>
          </div>
        </details>
        <details class="bg-gray-800 bg-opacity-50 p-4 rounded-lg group">
          <summary class="flex items-center justify-between text-xl font-semibold text-cyan-500 cursor-pointer ">
            <div class="max-w-full overflow-x-auto">
              <span class="inline-block whitespace-nowrap font-semibold text-cyan-500">
                SetWinEventHook Abuse
              </span>
            </div>
            <svg class="w-6 h-6 transform transition-transform duration-200 group-open:rotate-180 text-cyan-500" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"/>
            </svg>
          </summary>
          <div class="mt-4 relative ">
            <button class="absolute top-2 right-2 bg-indigo-500 text-white px-3 py-1 rounded text-sm" onclick="copyCode(this)">Copy</button>
            <pre class="mt-8 overflow-x-auto bg-gray-900 p-4 rounded-lg shadow-inner ">
              <code class="language-csharp text-green-300">
                using System;
                using System.Runtime.InteropServices;
                using System.Threading;
                
                class Program
                {
                    // Flag to ensure we only fire once
                    private static bool _fired;
                
                    // WinEvent hook callback signature
                    private delegate void WinEventDelegate(
                        IntPtr hWinEventHook,
                        uint eventType,
                        IntPtr hWnd,
                        int idObject,
                        int idChild,
                        uint dwEventThread,
                        uint dwmsEventTime
                    );
                
                    // POINT & MSG for message loop
                    [StructLayout(LayoutKind.Sequential)]
                    private struct POINT { public int X, Y; }
                
                    [StructLayout(LayoutKind.Sequential)]
                    private struct MSG
                    {
                        public IntPtr hwnd;
                        public uint message;
                        public UIntPtr wParam;
                        public IntPtr lParam;
                        public uint time;
                        public POINT pt;
                    }
                
                    private const uint PM_REMOVE = 0x0001;
                    private const uint EVENT_SYSTEM_FOREGROUND = 0x0003;
                    private const uint WINEVENT_OUTOFCONTEXT = 0;
                
                    [DllImport("user32.dll", SetLastError = true)]
                    private static extern IntPtr SetWinEventHook(
                        uint eventMin,
                        uint eventMax,
                        IntPtr hmodWinEventProc,
                        WinEventDelegate lpfnWinEventProc,
                        uint idProcess,
                        uint idThread,
                        uint dwFlags
                    );
                
                    [DllImport("user32.dll")]
                    private static extern bool UnhookWinEvent(IntPtr hWinEventHook);
                
                    [DllImport("user32.dll", CharSet = CharSet.Auto)]
                    private static extern int MessageBox(
                        IntPtr hWnd,
                        string text,
                        string caption,
                        uint type
                    );
                
                    [DllImport("user32.dll")]
                    private static extern bool PeekMessage(
                        out MSG lpMsg,
                        IntPtr hWnd,
                        uint wMsgFilterMin,
                        uint wMsgFilterMax,
                        uint wRemoveMsg
                    );
                
                    [DllImport("user32.dll")]
                    private static extern bool TranslateMessage([In] ref MSG lpMsg);
                
                    [DllImport("user32.dll")]
                    private static extern IntPtr DispatchMessage([In] ref MSG lpMsg);
                
                    static void Main()
                    {
                        Console.WriteLine("Registering foreground-change hook (EVENT_SYSTEM_FOREGROUND)...");
                        WinEventDelegate callback = WinEventProc;
                        IntPtr hook = SetWinEventHook(
                            EVENT_SYSTEM_FOREGROUND,
                            EVENT_SYSTEM_FOREGROUND,
                            IntPtr.Zero,
                            callback,
                            0,
                            0,
                            WINEVENT_OUTOFCONTEXT
                        );
                
                        if (hook == IntPtr.Zero)
                        {
                            Console.WriteLine("SetWinEventHook failed: " + Marshal.GetLastWin32Error());
                            return;
                        }
                
                        Console.WriteLine("Hook installed. Switch windows (e.g., Alt+Tab) to trigger once.");
                        Console.WriteLine("Press Enter to exit at any time.");
                
                        // Pump messages until our callback fires or user presses Enter
                        while (!_fired)
                        {
                            if (PeekMessage(out MSG msg, IntPtr.Zero, 0, 0, PM_REMOVE))
                            {
                                TranslateMessage(ref msg);
                                DispatchMessage(ref msg);
                            }
                            if (Console.KeyAvailable && Console.ReadKey(true).Key == ConsoleKey.Enter)
                                break;
                            Thread.Sleep(10);
                        }
                
                        UnhookWinEvent(hook);
                        Console.WriteLine("Hook removed; exiting.");
                    }
                
                    private static void WinEventProc(
                        IntPtr hWinEventHook,
                        uint eventType,
                        IntPtr hWnd,
                        int idObject,
                        int idChild,
                        uint dwEventThread,
                        uint dwmsEventTime
                    )
                    {
                        if (_fired)
                            return;
                
                        _fired = true;
                        MessageBox(
                            IntPtr.Zero,
                            $"Foreground changed to hWnd=0x{hWnd.ToInt64():X}",
                            "WinEvent Abuse",
                            0
                        );
                    }
                }                
              </code>
            </pre>
          </div>
        </details>
      </div>
      <br><br>
      <blockquote class="border-l-4 border-blue-400 pl-4">
        <strong>Assignment:</strong> Enhance this proof-of-concept to execute a different payload; the remaining callback techniques are yours to explore, enjoy the experimentation 🫡
      </blockquote>
      <br>
    </section>
    <style>
      .copy-button 
      {
        position: absolute;
        top: 10px;
        right: 15px;
        background-color: #1e293b;
        color: #f8fafc;
        border: none;
        padding: 5px 10px;
        font-size: 18px;
        cursor: pointer;
        border-radius: 5px;
        z-index: 2;
      }              
      .copy-button:hover 
      {
        background-color: #3b82f6;
      }              
    </style>
    <script>
      function copyCode(button) {
        const codeBlock = button.parentElement.querySelector('code');
        const text = codeBlock.textContent;
    
        navigator.clipboard.writeText(text).then(() => {
          button.textContent = 'Copied!';
          setTimeout(() => {
            button.textContent = 'Copy';
          }, 1500);
        });
      }
    </script>     
  </section>
  <footer class="flex flex-col items-center justify-center gap-4 py-6 bg-[#0f172a] text-gray-200">
    <p class="text-center">2025 Iron Hulk — No rights reserved.</p>
    <a href="../index.html" class="inline-block bg-blue-500 text-white text-sm px-4 py-2 rounded hover:bg-blue-600 transition">← Back to Dashboard</a>
  </footer>
</main>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const dateWritten = '20/Jan/2025';
      const words   = document.getElementById('article').innerText.trim().split(/\s+/).filter(Boolean).length;
      const minutes = Math.max(1, Math.ceil(words / 230));
      document.getElementById('reading-time').textContent = `Written: ${dateWritten} – ${minutes} min reading`;
    });
  </script>
</body>
</html>
