<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Iron Hulk – Detection Mechanisms</title>
  <script type="text/javascript" src="https://ff.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js?attr=gDQBIS02yr-aJ0KlNLJ0WcJ6qf_6oItzpZ7BY57f_Amb9vew_8pZ7jCzxUXCLR-mbE8vWD-X_LGRLfN6OqtUnXSp8ThR2tGIAqP7oL3QyLM" charset="UTF-8"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-[#0f172a] text-white font-sans min-h-screen">
  <!-- Header -->
  <header class="bg-[#1e293b] p-4 shadow flex items-center justify-between gap-4">
    <div>
      <h1 class="text-xl font-bold text-blue-400">Detection Mechanisms</h1>
      <small id="reading-time" class="text-xs text-gray-400"></small>
    </div>
    <a href="../index.html" class="text-gray-300 text-sm hover:underline">← Back to Dashboard</a>
  </header>

  <!-- Article -->
  <main id="article" class="p-6 space-y-6">
    <section class="bg-[#1f2937] p-6 rounded-xl shadow-md">
        <h2 class="text-2xl font-bold text-blue-400 mb-1">Introduction</h2>
        <p class="text-1xl text-gray-300 leading-relaxed text-justify pl-2">
            When you install an antivirus (AV) or an Endpoint Detection and Response (EDR) solution on your machine, you rarely stop to think about the intricate mechanisms working behind the scenes. 
            In reality, modern AV/EDR products employ a rich tapestry of detection strategies, evolving well beyond the “match a string of bytes” approach of early antivirus utilities. In this blog post, 
            we’re going to pull back the curtain and explore, in plain and engaging language, the many ways that AV/EDR platforms detect, flag, and neutralize malicious behavior. We’ll cover static 
            techniques (what the AV can see by inspecting files on disk), dynamic techniques (what it observes when code actually runs), and the clever hybrid and data-driven methods that have emerged over 
            the past decade. Along the way, we’ll dive deeply into each approach and how it works under the hood, why it sometimes misses threats, and how attackers adapt to evade it. By the end of this, 
            you’ll have a solid understanding of the “why” and “how” behind antivirus detection and EDR, and you’ll see why defenders often say that the cybersecurity arms race never sleeps.
        </p>
        <div class="mt-6"></div>        
        <h2 class="text-2xl font-bold text-blue-400 mb-1 pl-2">1. Static/Signature-Based Detection</h2>
        <p class="text-1xl text-gray-300 leading-relaxed text-justify pl-9">
            Static or Signature-based detection are the oldest and most straightforward technique, the AV maintains a massive database of “fingerprints” (byte sequences or hashes) that correspond to known malware.
            When you download a file or an incoming email attachment, the AV scans its contents and compares them against the signature database. A match means “known bad,” and the file is quarantined or deleted. 
            This approach is very fast and has a low false-positive rate for malware that matches exactly, but it falls short when malware authors change even a few bytes or pack their payloads dynamically.
        </p>
        <div class="mt-6"></div>
        <p class="font-bold pl-9">Deep Dive into the Mechanics:</p>
        <p class="text-1xl text-gray-300 leading-relaxed text-justify pl-9">
            Imagine you have a phonebook of criminals, each entry lists a name, a photo, and some identifying characteristics. Whenever someone new shows up, you flip through this phonebook to see if the face or name matches.
            Signature-based AV does something similar, except instead of mugshots, it looks for byte-patterns or cryptographic hashes (e.g., <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">MD5</code>, <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">SHA-256</code>) that uniquely identify a malicious file.
            <div class="mt-6"></div>
            <p class="font-bold pl-9">These patterns might be: </p>
            <ul class="list-disc list-outside pl-14 text-gray-300">
                <li>A specific sequence of bytes at offset <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">0x100</code> in the file, common to a particular ransomware family.</li>
                <li>The hash of a library or executable that is known to contain a trojan.</li>
                <li>Security engineers who want to move into offensive roles.</li>
                <li>A set of instructions or strings (such as “Decrypting payload” or <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">HttpPost /steal.php</code>) that consistently appear in malware samples.</li>
            </ul>
            <div class="mt-6"></div>
            <p class="text-1xl text-gray-300 leading-relaxed text-justify pl-9">
                When the AV vendor discovers a new piece of malware, lets say a banking trojan, they analyze it, extract several reliable byte-patterns, and push those patterns out in the next signature update. 
                Your AV, upon receiving the update, knows to look for those patterns on disk or in memory. If it finds them, it can immediately flag the file as malicious.
                <div class="mt-6"></div>
                <p class="font-bold pl-9">Strengths and Limitations: </p>
            <ul class="list-disc list-outside pl-14 text-justify text-gray-300">
                <li><strong>Speed and simplicity:</strong> Signature checks are usually just a matter of comparing short patterns, which modern AV engines do with highly optimized data structures (like <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">Bloom filters</code> or <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">trie-based indices</code>).</li>
                <li><strong>Low false positives:</strong> If a byte-pattern matches exactly, it’s almost certainly the same malware family.</li>
                <li><strong>Poor against minor modifications:</strong> Malware authors can recompile code, insert junk instructions, or pack/encrypt their payload so that the byte-pattern changes just enough to evade detection.</li>
                <li><strong>Reactive by nature:</strong> Signature databases are always cat and mouse game. Only after a threat is discovered, analyzed, and signatures extracted can the AV detect it. This leaves a window of “zero-day vulnerability” before the update arrives.</li>
            </ul>
        </p>
        <div class="mt-6"></div>
        <h2 class="text-2xl font-bold text-blue-400 mb-1 pl-2">2. Heuristic-Based Detection</h2>
        <p class="text-1xl text-gray-300 leading-relaxed text-justify pl-9">
            To catch threats that don’t yet have a signature, AV vendors introduced heuristics, rules that look for suspicious characteristics inside a file, rather than an exact byte match.
            These heuristics often involve scanning for “red flags” like encoded or obfuscated code, calls to low-level system functions that typically appear in malware (e.g., <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">VirtualAlloc</code>, <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">CreateRemoteThread</code>), 
            or even suspicious combinations of API calls. Rather than saying “this file is exactly the same as TrojanXYZ,” a heuristic-based engine might say “this file behaves a lot like ransomware because it encrypts files and then writes a ransom note.”
        </p>
        <div class="mt-6"></div>
        <p class="font-bold pl-9">Deep Dive into the Mechanics:</p>
        <p class="text-1xl text-gray-300 leading-relaxed text-justify pl-9">
            Think of a heuristic engine like a detective who knows that safe-crackers often carry lock-picking tools, wear gloves, and loiter around banks late at night. Even if the detective has never seen this particular individual before, seeing those telltale clues can raise suspicion.     
        </p>
        <div class="mt-6"></div>
        <p class="font-bold pl-9">In the AV context, heuristics might include: </p>
        <ul class="list-disc list-outside pl-14 text-justify text-gray-300">
            <li><strong>Unpacking routines:</strong> Many malware samples pack their real code inside multiple layers of encryption or compression. The heuristic engine might look for unusual patterns of “self-modifying” code, for instance, a loop that decrypts a buffer and then jumps into it.</li>
            <li><strong>Suspicious API sequences:</strong> If a file calls <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">CreateProcess</code> and then immediately injects code into another process (via <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">WriteProcessMemory</code> and <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">CreateRemoteThread</code>), that’s a strong heuristic indicator of process injection, a common malware technique.</li>
            <li><strong>Embedded shellcode:</strong> A heuristic might scan the file for a sequence of bytes that starts with typical shellcode instructions (like a PUSH/POP combination or a short JMP to relative address), even if it’s encrypted.</li>
            <li><strong>Abnormal PE characteristics:</strong> Executables usually follow a standard Portable Executable (PE) format, correct section sizes, valid import tables, and so on. If an AV sees an EXE with an oversized <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">.text</code> section full of zeroes, or one with an invalid header, it may flag it as malicious.</li>
            <li><strong>Heuristic scoring:</strong> Often, each suspicious attribute adds points to a cumulative “malware score.” If the sum of scores crosses a threshold, the engine declares the file malicious or “potentially malicious” and quarantines it for further analysis.</li>
        </ul>
        <div class="mt-6"></div>
        <p class="font-bold pl-9">Strengths and Limitations: </p>
            <ul class="list-disc list-outside pl-14 text-justify text-gray-300">
                <li><strong>Spots new versions of malware:</strong> By focusing on behavior indicators and code structures, heuristics can detect malware families that have changed just enough to evade signatures.</li>
                <li><strong>Higher false-positive risk:</strong> Because heuristics are based on general behaviors (e.g., “calls <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">VirtualAlloc</code> then writes to memory”), benign software that packs itself (like some legitimate installers) or debuggers that perform in-memory patching might trip the heuristics.</li>
                <li><strong>Tunable thresholds:</strong> AV vendors calibrate heuristic thresholds carefully, if they’re too strict, many harmless programs get flagged; if too lenient, malware slips through.</li>
                <li><strong>Requires expert tuning:</strong> The folks designing these rules need deep knowledge of Windows internals, common malware patterns, and the behaviors of legitimate software, so they don’t accidentally trash useful applications.</li>
            </ul>
        <div class="mt-6"></div>
        <h2 class="text-2xl font-bold text-blue-400 mb-1 pl-2">3. Behavior-Based and Behavioral Monitoring</h2>
        <p class="text-1xl text-gray-300 leading-relaxed text-justify pl-9">
            While heuristics focus on static clues inside a file before it runs, behavior-based detection watches what actually happens when a program executes. The AV/EDR hooks into various operating system functions such as kernel callbacks, user-mode API interceptions, or event tracing to observe actions like file creation, 
            registry modifications, process injection, or network connections. If a process starts encrypting every “.docx” file it finds (classic ransomware behavior) or injects code into system processes, the EDR flags and quarantines it.
        </p>
        <div class="mt-6"></div>
        <p class="font-bold pl-9">Deep Dive into the Mechanics:</p>
        <p class="text-1xl text-gray-300 leading-relaxed text-justify pl-9">
            Picture a security guard watching CCTV footage in real-time. They don’t care if the intruder is wearing a disguise (packed or obfuscated code), because the guard can see that the person is breaking into the server room (e.g., encrypting user data).
        </p>
        <div class="mt-6"></div>
        <p class="font-bold pl-9">Behavior-based detection is similar in principle:</p>
        <ul class="list-disc list-outside pl-14 text-gray-300">
            <li><strong>OS-Level Hooks: </strong></li>
                <ol class="list-[upper-alpha] list-outside pl-4 text-gray-300 text-1xl leading-relaxed text-justify">
                    <li><strong>Kernel-mode callbacks:</strong> 
                        On Windows, functions such as <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">PsSetCreateProcessNotifyRoutine</code>, <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">PsSetCreateThreadNotifyRoutine</code>, and <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">PsSetLoadImageNotifyRoutine</code> let a security driver receive events
                        when a process starts, a thread spawns, or an image loads. An EDR running in kernel mode can kill or quarantine the offender immediately.
                    </li>
                    <li><strong>User-mode API hooking:</strong>
                        The agent injects a small DLL into every process and patches the prologue of APIs like <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">OpenProcess</code>, <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">VirtualAlloc</code>, <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">WriteProcessMemory</code>, or uses <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">IAT</code> rewriting. The hook logs or blocks
                        the call if parameters look malicious.
                    </li>
                </ol>
                <div class="mt-6"></div>
            <li><strong>Real-Time File and Registry Monitoring: </strong></li>
                <ol class="list-[upper-alpha] list-outside pl-4 text-gray-300 text-1xl leading-relaxed text-justify">
                    <li><strong>File system filter drivers:</strong> 
                        An EDR can install a kernel-mode filter that sees every call to <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">CreateFile</code>, <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">WriteFile</code>, or <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">DeleteFile</code>. If a process starts modifying thousands of Office documents within 30 seconds, the system recognizes a sudden mass-encryption pattern and can halt the process.
                    </li>
                    <li><strong>Registry callbacks:</strong>
                        Using <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">PsSetCreateProcessNotifyRoutineEx</code> and other callback routines, an EDR watches registry access. If a process writes to <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-break-spaces">HKLM\Software\Microsoft\Windows\CurrentVersion\Run</code>, attempting to persist on reboot, it might be trying to create a malicious autorun entry. The EDR can stop or flag that behavior.
                    </li>
                </ol>
        </ul>
        <div class="mt-6"></div>
        <p class="font-bold pl-9">Strengths and Limitations: </p>
        <ul class="list-disc list-outside pl-14 text-justify text-gray-300">
            <li><strong>Accuracy:</strong> Watching real behavior reduces false positives, if a user is legitimately editing a document, that’s far different from a hidden service encrypting dozens of files.</li>
            <li><strong>Late-stage detection:</strong> Because the AV/EDR only flags things when code actually runs, there is still a small window where the malware can begin its damage (e.g., delete backups, exfiltrate data) before being stopped.</li>
            <li><strong>Performance overhead:</strong> Kernel callbacks, file filters, and API hooks add latency to every system call. Good EDR vendors optimize heavily, but if you install two memory scanners or multiple hooking products, you can see noticeable slowdowns.</li>
            <li><strong>Complexity of evasion:</strong> Advanced attackers sometimes use “living off the land” techniques, utilizing legitimate system utilities like PowerShell or WMI to do malicious work, thereby blending into normal behavior. Detecting these threats requires more sophisticated logic such as “Anomaly-Based Detection” and “Machine Learning”.</li>
        </ul>
        
    </section>
  </main>
  <!-- Footer -->
  <footer class="flex items-center justify-center py-6">
    <a href="../index.html" class="inline-block bg-blue-500 text-white text-sm px-4 py-2 rounded hover:bg-blue-600 transition">← Back to Dashboard</a>
  </footer>

  <!-- Reading-time logic -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const dateWritten = '25/May/2025';
      const words   = document.getElementById('article').innerText.trim().split(/\s+/).filter(Boolean).length;
      const minutes = Math.max(1, Math.ceil(words / 230));
      document.getElementById('reading-time').textContent = `Written: ${dateWritten} – ${minutes} min reading`;
    });
  </script>
</body>
</html>
