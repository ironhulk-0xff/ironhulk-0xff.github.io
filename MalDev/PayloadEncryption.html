<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Iron Hulk – System Call</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-[#0f172a] text-white font-sans min-h-screen">
  <!-- Header -->
  <header class="bg-[#1e293b] p-4 shadow flex items-center justify-between gap-4">
    <div>
      <h1 class="text-xl font-bold text-blue-400">System Call</h1>
      <small id="reading-time" class="text-xs text-gray-400"></small>
    </div>
    <a href="../index.html" class="text-gray-200  hover:underline">← Back to Dashboard</a>
  </header>
  <!-- Article -->
<main id="article" class="p-2 sm:text-justify ">
    <section class="relative mx-auto overflow-hidden rounded-3xl bg-gradient-to-br from-slate-800/90 via-slate-900 to-black p-10 ring-1 ring-cyan-500/20">
        <div class="absolute -left-16 w-48 h-48 bg-indigo-500 rounded-full opacity-20 mix-blend-screen filter blur-3xl"></div>
        <div class="bg-gray-800 bg-opacity-60 p-8 rounded-3xl shadow-2xl backdrop-blur-md">
        <h2 class="text-4xl font-bold text-indigo-300 mb-4">What Is a System Call?</h2>
        <p class="text-gray-200">
            A system call is the mechanism by which a user-mode application requests a service from the operating system’s kernel. Whenever you open a file, allocate memory, 
            create or terminate a process, or perform any I/O operation, your application invokes a system call. At a high level, the process goes like this: the application 
            executes a special instruction  that triggers a controlled switch from user mode to kernel mode. The kernel then validates the request, performs the requested operation 
            on behalf of the application, and returns control (and any results) back to user space. System calls constitute a protected boundary: without them, user-mode code 
            couldn’t directly manipulate hardware or critical OS data structures, preserving system stability and security.
        </p>
        <br>
        <blockquote class="border-l-4 border-blue-400 pl-4 italic">
            Why care? Syscalls are the only legal way to touch hardware/memory. Malware abuses them. Security tools spy on them.
        </blockquote>
        </div>
        <br>
        <div class="bg-gray-800 bg-opacity-60 p-8 rounded-3xl shadow-2xl backdrop-blur-md">
        <h2 class="text-4xl font-bold text-indigo-300 mb-4">What Is a Systemcall Service Number?</h2>
        <p class="text-gray-200">
            A system call service number (SSN) is basically an integer code that acts as a shortcut for the operating system to figure out which kernel function to run when an app makes a 
            request. Think of it like a phone extension so when you dial a number, it routes you to the right department (in this case, a specific kernel service). This number is 
            used in direct system calls to tell the kernel exactly what operation to perform, without passing around function names, which keeps things fast and efficient.
        </p><br>
        <div class="sm:grid sm:gap-8 sm:grid-cols-2 relative">
            <div class="group bg-gradient-to-br from-gray-800 to-gray-700 p-6 rounded-3xl shadow-2xl transform hover:scale-105 transition">
                <div class="flex items-center mb-4">
                <div class="p-3 bg-green-500 rounded-full group-hover:bg-green-400 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                    </svg>
                </div>
                <h3 class="ml-4 text-2xl font-semibold text-green-300">Windows (SSDT Index)</h3>
                </div>
                <p class="text-gray-200 leading-relaxed">
                    The System Service Dispatch Table (SSDT) holds pointers to every kernel routine exposed via <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">Nt/Zw</code> calls. When you invoke a syscall stub in 
                    <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">ntdll.dll</code>, it loads its corresponding service number into the <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">EAX (x86)</code> or <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">RAX (x64)</code> register and executes the syscall 
                    (or sysenter) instruction. The kernel uses that value as an index into the SSDT to dispatch to the correct function. For example:
                </p>
                    <ul class="list-none space-y-2 text-gray-200">
                        <li class="flex items-center">
                            <span class="inline-block w-2 h-2 bg-green-400 rounded-full mr-3"></span>
                            <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">NtCreateFile</code> → <span class="font-semibold text-green-300"> 0x55</span>
                        </li>
                        <li class="flex items-center">
                            <span class="inline-block w-2 h-2 bg-green-400 rounded-full mr-3"></span>
                            <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">NtOpenProcess </code> → <span class="font-semibold text-green-300"> 0x23</span>
                        </li>
                        <li class="flex items-center">
                            <span class="inline-block w-2 h-2 bg-green-400 rounded-full mr-3"></span>
                            <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">NtAllocateVirtualMemory </code> → <span class="font-semibold text-green-300"> 0x18</span>
                        </li>
                        <li class="flex items-center">
                            <span class="inline-block w-2 h-2 bg-green-400 rounded-full mr-3"></span>
                            <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">NtCreateTimer </code> → <span class="font-semibold text-green-300"> 0xCB</span>
                        </li>
                    </ul>

            </div>
            <div class="group bg-gradient-to-br from-gray-800 to-gray-700 p-6 rounded-3xl shadow-2xl transform hover:scale-105 transition">
                <div class="flex items-center mb-4">
                <div class="p-3 bg-yellow-500 rounded-full group-hover:bg-yellow-400 transition">
                    <!-- Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                    </svg>
                </div>
                <h3 class="ml-4 text-2xl font-semibold text-yellow-300">Linux (SYSCALL Table Index)</h3>
                </div>
                <p class="text-gray-200 leading-relaxed">
                    System calls are defined in a syscall table, often in arch/x86/entry/syscalls/syscall_64.tbl or similar. User code places the syscall number in the 
                    RAX register, arguments in RDI, RSI, etc., and then executes syscall. The kernel reads RAX, looks up the handler in its internal table, and jumps there. For 
                    instance, on x86_64:
                </p>
                    <ul class="list-none space-y-2 text-gray-200">
                        <li class="flex items-center">
                            <span class="inline-block w-2 h-2 bg-yellow-400 rounded-full mr-3"></span>
                            <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">read()</code> → <span class="font-semibold text-yellow-300"> 0</span>
                        </li>
                        <li class="flex items-center">
                            <span class="inline-block w-2 h-2 bg-yellow-400 rounded-full mr-3"></span>
                            <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">write()</code> → <span class="font-semibold text-yellow-300"> 1</span>
                        </li>
                        <li class="flex items-center">
                            <span class="inline-block w-2 h-2 bg-yellow-400 rounded-full mr-3"></span>
                            <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">open()</code> → <span class="font-semibold text-yellow-300"> 2</span>
                        </li>
                        <li class="flex items-center">
                            <span class="inline-block w-2 h-2 bg-yellow-400 rounded-full mr-3"></span>
                            <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">execve()</code> → <span class="font-semibold text-yellow-300"> 59</span>
                        </li>
                    </ul>
            </div>
        </div>
        <br>
        <blockquote class="border-l-4 border-blue-400 pl-4 italic">
            Note: Service numbers vary by Windows version and build, never hard-code; always query dynamically. Try Hell's Gate, FreshyCalls or SysWhispers3.
        </blockquote>
        </div>   
        <br>     
        <div class="bg-gray-800 bg-opacity-60 p-8 rounded-3xl shadow-2xl backdrop-blur-md">
        <h2 class="text-4xl font-bold text-green-300 text-center">Direct/Indirect System Calls</h2><br>
        <div class="flex flex-col md:flex-row gap-8">
            <div class="flex-1 bg-gray-800 bg-opacity-60 p-6 rounded-3xl shadow-xl transform hover:scale-105 transition">
                <h3 class="text-2xl font-semibold text-green-300 mb-3">Direct Syscalls</h3>
                <p class="text-gray-200">
                    A direct system call is when an application or malware directly invokes a kernel function without going through any intermediate layers or standard libraries. 
                    This means the code is essentially talking straight to the operating system's kernel using low-level mechanisms. For example, on Windows, it's similar but often involves
                    functions from the Native API, such as <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">NtCreateFile</code> or <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">ZwWriteFile</code>, which are part of the System Service Dispatch Table (SSDT).
                    </p>
                    <br>
                <p><strong>In practice:</strong></p>
                <p class="text-gray-200">
                    When a direct system call is made, the CPU switches from user mode to kernel mode via a special instruction like <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">int 0x80</code> on older x86 systems or syscall on 
                    modern AMD64. The kernel then handles the request directly based on the syscall number and parameters passed. This bypasses any user-space wrappers, giving you 
                    raw access to kernel services.
                </p>
                <br>
                <p><strong>Advantages:</strong></p>
                <p class="text-gray-200">
                    Offers high performance and evasion potential by bypassing user-mode hooks in EDR tools, making it ideal for stealthy code execution in pen tests. 
                    Direct calls reduce detection chances in initial access phases.
                </p>
                <br>
                <p><strong>Disadvantages:</strong></p>
                <p class="text-gray-200">
                    Highly platform-specific, with syscall numbers changing across OS updates, leading to crashes if not handled dynamically. Also, kernel-level monitoring can flag 
                    them as suspicious, increasing detection risk.
                </p>
            </div>
            <div class="flex-1 bg-gray-800 bg-opacity-60 p-6 rounded-3xl shadow-xl transform hover:scale-105 transition">
                <h3 class="text-2xl font-semibold text-yellow-300 mb-3">Indirect Syscalls</h3>
                <p class="text-gray-200">
                    An indirect system call, on the other hand, involves invoking a kernel service through higher-level abstractions, like standard libraries or APIs, rather than 
                    directly addressing the kernel. Here, the application uses functions from user-space libraries like <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">fopen</code> from libc on Linux or <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">CreateFileW</code> from the Windows API
                    to make the call. These libraries act as intermediaries, translating your request into the actual kernel syscall behind the scenes.
                </p>
                <br>
                <p><strong>In practice:</strong></p>
                <p class="text-gray-200">
                    When you call an indirect system call, the library handles the details such as mapping the function to the correct syscall number, managing parameters, and dealing 
                    with any OS-specific quirks before the request is passed to the kernel. For example, calling <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">fopen</code> in C doesn't directly use the syscall instruction; instead, it 
                    goes through libc, which then invokes the appropriate kernel function like <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">sys_open</code> on Linux. This adds a layer of indirection, making the code more readable and 
                    portable but also introducing potential overhead.
                </p>
                <br>
                <p><strong>Advantages:</strong></p>
                <p class="text-gray-200">
                    Easier to implement and more portable, allowing code to run across different OSes without major changes. Can blend with legitimate traffic for better stealth in 
                    less-monitored environments.
                </p>
                <br>
                <p><strong>Disadvantages:</strong></p>
                <p class="text-gray-200">
                    Adds performance overhead and is vulnerable to API hooking, making it less reliable for evasion in advanced EDR setups.
                </p>
            </div>
        </div>
        </div>
        <br>
        <div class="flex-1 bg-gray-800 bg-opacity-60 p-6 rounded-3xl shadow-xl transform ">
        <div class="mx-auto px-6">
        <h2 class="text-center mb-12 text-5xl font-extrabold text-gradient-to-r from-red-500 to-pink-500">Why Direct Syscalls Are Watched Most By AV/EDR</h2>
        <div class="grid gap-8 md:grid-cols-2 lg:grid-cols-2">
            <div class="group bg-gray-900 hover:bg-red-900 transition p-6 rounded-2xl shadow-xl ">
            <div class="flex items-center mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-red-400 group-hover:text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M12 1l8 4v6c0 5.523-3.582 10.74-8 12-4.418-1.26-8-6.477-8-12V5l8-4z" />
                </svg>
                <h3 class="ml-3 text-2xl font-semibold">Behavioral and Anomaly Detection</h3>
            </div>
            <p class="text-gray-300 leading-relaxed">
                EDR tools use syscall monitoring to build behavioral baselines. For instance, tools like CrowdStrike or Microsoft Defender analyze syscall sequences to spot 
                deviations from normal patterns. If a process suddenly makes unusual syscalls such as rapid file reads/writes, it could flag ransomware or exploit attempts. 
                This is more effective than monitoring less critical areas like user-mode APIs alone.
            </p>
            </div>
            <div class="group bg-gray-900 hover:bg-green-800 transition p-6 rounded-2xl shadow-xl">
            <div class="flex items-center mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-green-400 group-hover:text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M6 9l6 6m0 0l6-6m-6 6V3" />
                </svg>
                <h3 class="ml-3 text-2xl font-semibold">Universal Gateway to the Kernel</h3>
            </div>
            <p class="text-gray-300 leading-relaxed">
                Every sensitive operation such as file I/O, memory allocation, process/thread control, DLL loading, ultimately happens via a syscall. By monitoring these low-level entry points, AV/EDR solutions 
                gain visibility over all critical system activity, regardless of which library or shim the attacker uses.
            </p>
            </div>
            <div class="group bg-gray-900 hover:bg-blue-800 transition p-6 rounded-2xl shadow-xl">
            <div class="flex items-center mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-blue-400 group-hover:text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M3 7v10a1 1 0 001 1h2m10 0h2a1 1 0 001-1V7m-6-4v4m0 0H9m3 0h3" />
                </svg>
                <h3 class="ml-3 text-2xl font-semibold">Evasion and Stealth Challenges</h3>
            </div>
            <p class="text-gray-300 leading-relaxed">
                Malware often tries to evade detection by manipulating syscalls like, using direct syscalls to bypass API hooks. As a result, AV/EDR has evolved to focus heavily 
                on syscall-level interception through kernel hooks, ETW (Event Tracing for Windows), or eBPF (on Linux) to cover both direct and indirect calls. This makes syscalls 
                a "must-watch" area, as they're harder for attackers to obfuscate completely.
            </p>
            </div>
            <div class="group bg-gray-900 hover:bg-purple-800 transition p-6 rounded-2xl shadow-xl">
            <div class="flex items-center mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-purple-400 group-hover:text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M11 12h6m2 0a2 2 0 11-4 0 2 2 0 014 0zm-8 0a2 2 0 11-4 0 2 2 0 014 0zm2 0v3m0-6V5m0 0H5m10 0h4" />
                </svg>
                <h3 class="ml-3 text-2xl font-semibold">High-Value, High-Risk Targets</h3>
            </div>
            <p class="text-gray-300 leading-relaxed">
                Certain syscall families like process creation, memory manipulation, module loading are disproportionately used in exploits and code-injection attacks. AV/EDR tools 
                prioritize these “high-risk” indices in the Service Dispatch Table to optimize performance while minimizing blind spots.
            </p>
            </div>
        </div>
        </div>
        <br>
        <blockquote class="border-l-4 border-blue-400 pl-4 italic">
        In short:
        <br>
        In short, syscalls are watched most because they're a concentrated point of risk, defenders get maximum insight with minimal false positives, while attackers see them as a 
        key to success. This makes understanding syscall monitoring essential for both red-team evasion and blue-team hardening.
        </blockquote>
        </div>
        <br>
        <div class="bg-gray-800 bg-opacity-60 p-8 rounded-3xl shadow-2xl backdrop-blur-md">
        <h2 class="text-4xl font-bold text-indigo-300 mb-4">Cybersecurity Takeaways</h2>
        <p class="text-gray-200">
        <strong>Offensive Angle:</strong> If you're testing defenses, leveraging direct calls can help evade initial detection since they're less commonly monitored. For example, in a red-team 
        exercise, using direct syscalls might bypass API-based hooks, giving you an edge in stealthy persistence. However, if EDR is tuned for kernel-level monitoring, it could 
        backfire and alert defenders faster.
        </p>
        <p class="text-gray-200">
        <strong>Defensive Angle:</strong> As a blue-teamer, focusing your monitoring on indirect calls provides the best bang for your buck, covering 80-90% of potential threats 
        with less overhead. But always layer in direct call detection for high-confidence alerts.
        </p>
        </div>
        <br>
        <div class="bg-gray-800 bg-opacity-60 p-8 rounded-3xl shadow-2xl backdrop-blur-md">
        <h2 class="text-center mb-12 text-5xl font-extrabold text-gradient-to-r from-red-500 to-pink-500">Evasion Techniques</h2>
        <div class="max-w-4xl mx-auto space-y-15">
        <div class="relative before:absolute before:top-0 before:left-1/2 before:-ml-px before:h-full before:w-1 before:bg-gray-700">
            <div class="flex items-center justify-between w-full">
            <div class="w-1/2 pr-8 text-right py-10">
                <h4 class="text-2xl font-semibold text-yellow-400 mb-3">Using Direct Syscall</h4>
                <p class="mt-4 text-gray-300 text-left sm:text-justify">
                    Bypasses user-mode hooks by issuing the <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">syscall/sysenter</code> instruction directly or calling the <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">Nt* stub</code> in <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">ntdll.dll</code> by index. 
                    No Win32/API wrapper, no IAT entry, AV/EDR misses most of these calls.
                </p>
            </div>
            <div class="flex-shrink-0">
                <div class="w-8 h-8  rounded-full flex items-center justify-center text-white font-bold"></div>
            </div>
            </div>
            <div class="flex items-center justify-between w-full">
            <div class="flex-shrink-0">
                <div class="w-8 h-8 rounded-full flex items-center justify-left text-white font-bold"></div>
            </div>
            <div class="w-1/2 pl-8 ">
                <h4 class="text-2xl font-semibold text-green-400 mb-3">Hell’s Gate & SysWhispers</h4>
                <p class="mt-4 text-gray-300 text-left sm:text-justify">
                    Dynamically resolve and invoke syscalls by patching in-memory stubs that map to kernel service numbers, avoiding static import of <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">ntdll.dll</code> functions. 
                    This thwarts signature-based detection of known syscall trampolines.
                </p>
            </div>
            </div>
            <div class="flex items-center justify-between w-full">
            <div class="w-1/2 pr-8 text-right">
                <h4 class="text-2xl font-semibold text-blue-400 mb-3">Syscall Proxying and Obfuscation</h4>
                <p class="mt-4 text-gray-300 text-left sm:text-justify">
                    Redirect syscall calls through custom proxies or wrappers to mask their origin. On Linux, you might hook into the syscall table with a user-defined function that 
                    randomizes parameters or adds noise, confusing behavioral analyzers. In Windows, techniques like syscall proxying can involve injecting code that mimics legitimate 
                    processes, making it tougher for ETW logging to pin down malicious activity.
                </p>
            </div>
            <div class="flex-shrink-0">
                <div class="w-8 h-8 rounded-full flex items-center justify-center text-white font-bold"></div>
            </div>
            </div>
            <div class="flex items-center justify-between w-full">
                <div class="flex-shrink-0">
                    <div class="w-8 h-8 rounded-full flex items-center justify-left text-white font-bold"></div>
                </div>
                <div class="w-1/2 pl-8 ">
                    <h4 class="text-2xl font-semibold text-orange-400 mb-3">Syscall Randomization and Dynamic Loading</h4>
                    <p class="mt-4 text-gray-300 text-left sm:text-justify">
                        Instead of sticking to static syscall numbers, randomize or load them at runtime to avoid predictable patterns that EDR tools might flag. 
                        For example, in Windows, you could write code that scans the PEB (Process Environment Block) or uses libraries like HalosGate to dynamically fetch and 
                        invoke syscall indices. On Linux, leverage tools or custom scripts to alter syscall arguments or use seccomp filters to mask calls, making it harder for 
                        behavioral analyzers to build a profile of your activity. This technique helps evade machine learning-based detection by introducing variability, perfect 
                        for red-team exercises where you want to simulate adaptive threats.
                    </p>
                </div>
            </div>
        </div>
        </div>
        </div>
        <br>
        <div class="bg-gray-800 bg-opacity-60 p-8 rounded-3xl shadow-2xl backdrop-blur-md">
        <h2 class="text-center mb-12 text-5xl font-extrabold text-gradient-to-r from-red-500 to-pink-500">Real-World Case Studies</h2>
        <div class="space-y-8">
        <!-- Turla -->
        <div class="flex items-start space-x-6">
        <div class="mt-1">
            <span class="inline-block w-4 h-4 bg-yellow-400 rounded-full"></span>
        </div>
        <div>
            <h4 class="text-2xl font-semibold text-yellow-400">SolarWinds Supply Chain Attack (2020):</h4>
            <p class="text-gray-300 mt-1">
                In this high-profile incident, attackers manipulated syscalls to maintain persistence and evade detection.
                They used direct syscall invocations to interact with kernel objects without triggering user-mode hooks, allowing them to move laterally and steal data for months. 
                Takeaway for pen testers, this shows how dynamic syscall handling can bypass even mature EDR systems, try replicating this in your tests to expose similar weaknesses.
            </p>
        </div>
        </div>
        <!-- Cobalt Strike -->
        <div class="flex items-start space-x-6">
        <div class="mt-1">
            <span class="inline-block w-4 h-4 bg-green-400 rounded-full"></span>
        </div>
        <div>
            <h4 class="text-2xl font-semibold text-green-400">Cobalt Strike HalosGate & HellsGate syscaller:</h4>
            <p class="text-gray-300 mt-1">
                Cobalt Strike’s HalosGate & HellsGate syscaller technique dynamically builds syscall stubs at runtime, pulling the SSDT index from <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">KiServiceTable</code>. 
                This allowed red-team operators to call syscalls by number without ever importing native API functions, evading both user-mode and basic kernel-mode hooks.
            </p>
        </div>
        </div>
        <!-- Ryuk -->
        <div class="flex items-start space-x-6">
        <div class="mt-1">
            <span class="inline-block w-4 h-4 bg-blue-400 rounded-full"></span>
        </div>
        <div>
            <h4 class="text-2xl font-semibold text-blue-400">WannaCry Ransomware (2017):</h4>
            <p class="text-gray-300 mt-1">
                While not syscall-specific, WannaCry leveraged indirect syscalls for file encryption, but advanced variants learned from it. 
                Modern ransomware now often mixes direct and indirect calls to confuse monitors. For example, using <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">NtCreateFile</code> directly for speed while avoiding API logs. 
                Lesson: Evasion isn't just about speed; it's about adaptability, test how your syscall-based tools hold up against behavioral analytics in a lab.
            </p>
        </div>
        </div>
        <!-- Discord Loader -->
        <div class="flex items-start space-x-6">
        <div class="mt-1">
            <span class="inline-block w-4 h-4 bg-purple-400 rounded-full"></span>
        </div>
        <div>
            <h4 class="text-2xl font-semibold text-purple-400">Discord Loader (2021)</h4>
            <p class="text-gray-300 mt-1">
                A loader distributed via Discord abused Linux’s <code class="bg-[#334155] text-blue-300 rounded px-1 break-words whitespace-normal">io_uring</code> interface to download and write payloads in a single batched syscall submission. 
                Defenders monitoring only individual read/write syscalls missed the combined operation, delaying detection.
            </p>
        </div>
        </div>
        </div>
        </div>
        <br>
        <div class="bg-gray-800 bg-opacity-60 p-8 rounded-3xl shadow-2xl backdrop-blur-md">
        <h2 class="text-4xl font-bold text-green-300 text-center">Project</h2><br>
        <details class="bg-gray-800 bg-opacity-50 p-4 rounded-lg group">
        <summary class="flex items-center justify-between text-xl font-semibold text-cyan-500 cursor-pointer ">
            <div class="max-w-full overflow-x-auto">
            <span class="inline-block whitespace-nowrap font-semibold text-cyan-500">
                SSN Enumeration
            </span>
            </div>
            <svg class="w-6 h-6 transform transition-transform duration-200 group-open:rotate-180 text-cyan-500" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"/>
            </svg>
        </summary>
        <div class="relative ">
            <button class="absolute top-2 right-2 bg-indigo-500 text-white px-3 py-1 rounded text-sm" onclick="copyCode(this)">Copy</button>
            <pre class=" overflow-x-auto bg-gray-900 p-4 rounded-lg shadow-inner ">
            <pre><code class="language-cpp text-green-300">
                // Project Name: Syscall-SSN Enumerator
                // By: Iron Hulk
                
                #include &lt;windows.h&gt;
                #include &lt;iostream&gt;
                #include &lt;vector&gt;
                #include &lt;string&gt;
                #include &lt;sstream&gt;
                #include &lt;iomanip&gt;
                
                typedef LONG (NTAPI* RtlGetVersionPtr)(PRTL_OSVERSIONINFOEXW);
                
                struct ExportInfo {
                    std::string name;
                    DWORD       ssn;
                };
                
                std::vector&lt;ExportInfo&gt; GetNtExportsSSN() {
                    HMODULE hNtdll = LoadLibraryW(L"ntdll.dll");
                    if (!hNtdll) throw std::runtime_error("LoadLibrary failed");
                
                    auto dos     = reinterpret_cast&lt;PIMAGE_DOS_HEADER&gt;(hNtdll);
                    auto nt      = reinterpret_cast&lt;PIMAGE_NT_HEADERS&gt;(
                                        reinterpret_cast&lt;BYTE*&gt;(hNtdll) + dos-&gt;e_lfanew);
                    auto exports = reinterpret_cast&lt;PIMAGE_EXPORT_DIRECTORY&gt;(
                                        reinterpret_cast&lt;BYTE*&gt;(hNtdll) +
                                        nt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
                
                    auto names = reinterpret_cast&lt;DWORD*&gt;(
                                    reinterpret_cast&lt;BYTE*&gt;(hNtdll) + exports-&gt;AddressOfNames);
                    auto funcs = reinterpret_cast&lt;DWORD*&gt;(
                                    reinterpret_cast&lt;BYTE*&gt;(hNtdll) + exports-&gt;AddressOfFunctions);
                    auto ords  = reinterpret_cast&lt;WORD*&gt;(
                                    reinterpret_cast&lt;BYTE*&gt;(hNtdll) + exports-&gt;AddressOfNameOrdinals);
                
                    std::vector&lt;ExportInfo&gt; list;
                    for (DWORD i = 0; i &lt; exports-&gt;NumberOfNames; ++i) {
                        const char* fnName = reinterpret_cast&lt;const char*&gt;(hNtdll) + names[i];
                        DWORD       rva    = funcs[ords[i]];
                        BYTE*       stub   = reinterpret_cast&lt;BYTE*&gt;(hNtdll) + rva;
                
                        /* mov r10, rcx ; mov eax, imm32 ; syscall */
                        if (stub[0] == 0x4C &amp;&amp; stub[1] == 0x8B &amp;&amp; stub[2] == 0xD1 &amp;&amp; stub[3] == 0xB8) {
                            DWORD ssn = *reinterpret_cast&lt;DWORD*&gt;(stub + 4);
                            list.push_back({ fnName, ssn });
                        }
                    }
                    return list;
                }
                
                int main() {
                    OSVERSIONINFOEXW osvi = {};
                    osvi.dwOSVersionInfoSize = sizeof(osvi);
                
                    if (auto hNtDll = GetModuleHandleW(L"ntdll.dll")) {
                        auto rtlGetVersion = reinterpret_cast&lt;RtlGetVersionPtr&gt;(
                                                GetProcAddress(hNtDll, "RtlGetVersion"));
                        if (rtlGetVersion)
                            rtlGetVersion(&amp;osvi);
                        else
                            GetVersionExW(reinterpret_cast&lt;OSVERSIONINFOW*&gt;(&amp;osvi)); // legacy
                    }
                
                    std::wstring osName;
                    if (osvi.dwMajorVersion == 10)
                        osName = (osvi.dwBuildNumber &gt;= 22000) ? L"Windows 11" : L"Windows 10";
                    else if (osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 3) osName = L"Windows 8.1";
                    else if (osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 2) osName = L"Windows 8";
                    else if (osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 1) osName = L"Windows 7";
                    else                                                         osName = L"Windows (unknown)";
                
                    std::wcout &lt;&lt; L"OS Name:    " &lt;&lt; osName &lt;&lt; L"\n"
                                &lt;&lt; L"OS Version: "
                                &lt;&lt; osvi.dwMajorVersion &lt;&lt; L'.'
                                &lt;&lt; osvi.dwMinorVersion &lt;&lt; L" (Build "
                                &lt;&lt; osvi.dwBuildNumber  &lt;&lt; L")\n";
                
                    BOOL isWow64 = FALSE;
                    auto fnIsWow64 = reinterpret_cast&lt;BOOL (WINAPI*)(HANDLE,PBOOL)&gt;(
                                        GetProcAddress(GetModuleHandleA("kernel32"), "IsWow64Process"));
                
                #ifdef _WIN64
                    std::cout &lt;&lt; "Process architecture: x64\nOS architecture:      x64\n";
                #else
                    std::cout &lt;&lt; "Process architecture: x86\n";
                    if (fnIsWow64 &amp;&amp; fnIsWow64(GetCurrentProcess(), &amp;isWow64) &amp;&amp; isWow64)
                        std::cout &lt;&lt; "OS architecture:      x64 (WOW64)\n";
                    else
                        std::cout &lt;&lt; "OS architecture:      x86\n";
                #endif
                
                    std::cout &lt;&lt; "\nSyscall SSNs:\n\n";
                
                    try {
                        auto exports = GetNtExportsSSN();
                
                        std::cout &lt;&lt; std::left  &lt;&lt; std::setw(60) &lt;&lt; "Syscall"
                                    &lt;&lt; " | " &lt;&lt; std::right &lt;&lt; std::setw(7) &lt;&lt; "Decimal"
                                    &lt;&lt; " | " &lt;&lt; std::right &lt;&lt; std::setw(7) &lt;&lt; "Hex\n"
                                    &lt;&lt; std::string(60,'-') &lt;&lt; "-+-"
                                    &lt;&lt; std::string(7,'-')  &lt;&lt; "-+-"
                                    &lt;&lt; std::string(7,'-')  &lt;&lt; '\n';
                
                        for (const auto&amp; e : exports) {
                            std::ostringstream hex; hex &lt;&lt; "0x" &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; e.ssn;
                            std::cout &lt;&lt; std::left  &lt;&lt; std::setw(60) &lt;&lt; e.name
                                        &lt;&lt; " | " &lt;&lt; std::right &lt;&lt; std::setw(7) &lt;&lt; std::dec &lt;&lt; e.ssn
                                        &lt;&lt; " | " &lt;&lt; std::right &lt;&lt; std::setw(7) &lt;&lt; hex.str() &lt;&lt; '\n';
                        }
                    } catch (const std::exception&amp; ex) {
                        std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; '\n';
                        return 1;
                    }
                    return 0;
                }
                </code>
            </pre>
            </pre>
        </div>
        </details>          
        <style>
        .copy-button 
        {
            position: absolute;
            top: 10px;
            right: 15px;
            background-color: #1e293b;
            color: #f8fafc;
            border: none;
            padding: 5px 10px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 2;
        }              
        .copy-button:hover 
        {
            background-color: #3b82f6;
        }
        </style>
        <script>
        function copyCode(button) {
            const codeBlock = button.parentElement.querySelector('code');
            const text = codeBlock.textContent;

            navigator.clipboard.writeText(text).then(() => {
            button.textContent = 'Copied!';
            setTimeout(() => {
                button.textContent = 'Copy';
            }, 1500);
            });
        }
        </script>   
        </div>
    </section>
    <footer class="flex flex-col items-center justify-center gap-4 py-6 bg-[#0f172a] text-gray-200">
        <p class="text-center">Crafted with passion<br>2025 Iron Hulk — No rights reserved.</p>
        <a href="../index.html" class="inline-block bg-blue-500 text-white text-sm px-4 py-2 rounded hover:bg-blue-600 transition">← Back to Dashboard</a>
    </footer>
</main>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const dateWritten = '20/Jan/2025';
      const words   = document.getElementById('article').innerText.trim().split(/\s+/).filter(Boolean).length;
      const minutes = Math.max(1, Math.ceil(words / 230));
      document.getElementById('reading-time').textContent = `Written: ${dateWritten} – ${minutes} min reading`;
    });
  </script>
</body>
</html>
